// Copyright 2025 URAV ADVANCED LEARNING SYSTEMS PRIVATE LIMITED
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Volume population based on: https://github.com/anaglyphs/lasertag
// MIT License
// 
// Copyright (c) 2024 Julian Triveri & Hazel Roeder
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#include "DepthUtils.hlsl"

RWTexture3D<half> Volume;
uniform uint3 VolumeSize;
uniform float MetersPerVoxel;

uniform StructuredBuffer<float3> FrustumVolume;
uniform float4x4 ViewToWorldMatrices[2];
uniform float4x4 WorldToTrackingMatrix;
uniform float4x4 TrackingToWorldMatrix;
uniform float3 UserWorldPos;

uniform uint MaxTriangles;
RWStructuredBuffer<float3> VertexBuffer;
RWStructuredBuffer<uint3> IndexBuffer;
RWStructuredBuffer<uint> ValidTriangleCounter;
RWStructuredBuffer<uint> ValidVertexCounter;

#define ISO_LEVEL 0.0
#define USER_TOP 0.2 
#define USER_BOTTOM 1.7
#define USER_RADIUS 0.5
#define MIN_DOT 0.3

float3 EyePosition()
{
    return ViewToWorldMatrices[0]._m03_m13_m23;
}

float3 VoxelToWorldPos(float3 pos)
{
    pos += 0.5f;
	pos -= VolumeSize / 2.0f;
	pos *= MetersPerVoxel;

	return mul(TrackingToWorldMatrix, float4(pos, 1)).xyz;
}

uint3 WorldToVoxelPos(float3 pos)
{
    pos = mul(WorldToTrackingMatrix, float4(pos, 1)).xyz;
	pos /= MetersPerVoxel;
	pos += VolumeSize / 2.0f;
	return clamp(uint3(pos), 0, VolumeSize - 1);
}

bool IsInUserPos(float3 pos) {
    return distance(pos.xz, UserWorldPos.xz) < USER_RADIUS
            && pos.y < UserWorldPos.y + USER_TOP
            && pos.y > UserWorldPos.y - USER_BOTTOM;
}

#pragma kernel Clear

[numthreads(8, 2, 8)]
void Clear(uint3 id: SV_DispatchThreadID)
{
	Volume[id] = 1.0;
}

#pragma kernel UpdateVoxels

[numthreads(128, 1, 1)]
void UpdateVoxels(uint i: SV_DispatchThreadID)
{
    const float3 fineVoxelWorldPos = mul(ViewToWorldMatrices[0], float4(FrustumVolume[i], 1)).xyz;
    if (IsInUserPos(fineVoxelWorldPos)) {
        return;
    }

    const uint3 id = WorldToVoxelPos(fineVoxelWorldPos);

    const float3 eyePos = EyePosition();
    const float3 voxelPos = VoxelToWorldPos((float3)id);

    const float2 voxelNDC = WorldToNDCPos(voxelPos).xy;
    const float3 depthPos = SampleDepthPosition(voxelNDC);

    const float voxelEyeDist = distance(voxelPos, eyePos);
    const float depthEyeDist = distance(depthPos, eyePos);

    const float3 eyeToVoxel = voxelPos - eyePos;
    const float3 depthNormal = SampleDepthNormal(voxelNDC);

    float sDist = depthEyeDist - voxelEyeDist;
    const float normalDot = -dot(normalize(eyeToVoxel), depthNormal);
    sDist *= saturate(normalDot);

    const half sDistNorm = min(sDist / MetersPerVoxel, 1);
    if (sDistNorm > -1 && normalDot > MIN_DOT) {
        Volume[id] = sDistNorm;
    }
}

// Surface Nets implementation based on: https://github.com/Q-Minh/naive-surface-nets/
// MIT License
// 
// Copyright (c) 2020 Quoc-Minh Ton-That
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#pragma kernel SurfaceNetsVertexPass
#pragma kernel SurfaceNetsTrianglePass
#pragma kernel VertexIndexBufferClear

#define INVALID_VERTEX  0xffffffff
#define INVALID_DEPTH   0xfffffffe
#define INVALID_SCALAR  -100.0f

// Temporary buffer to store vertex indices per voxel cell
RWStructuredBuffer<uint> VertexIndexBuffer;
uniform float MaxMeshUpdateDistance;

// the edges provide indices to the corresponding current cube's vertices (voxel corners)
static const uint2 edgeTable[12] =
{
	uint2(0u, 1u),
	uint2(1u, 2u),
	uint2(2u, 3u),
	uint2(3u, 0u),
	uint2(4u, 5u),
	uint2(5u, 6u),
	uint2(6u, 7u),
	uint2(7u, 4u),
	uint2(0u, 4u),
	uint2(1u, 5u),
	uint2(2u, 6u),
	uint2(3u, 7u)
};

static const uint3 quadNeighbors[3] =
{
	uint3(0, 1, 2),
	uint3(0, 5, 4),
	uint3(2, 3, 4)
};

static const uint3 quadNeighborOrders[2] =
{
	uint3(0, 1, 2),
	uint3(2, 1, 0)
};

uint GetVIBufferIndex(uint3 cellId) {
    return cellId.x + cellId.y * VolumeSize.x + cellId.z * VolumeSize.x * VolumeSize.y;
}

uint3 CubeVertex(uint index)
{
    bool x = index & 1;
    bool y = index & 2;
    bool z = index & 4;
    return uint3(x ^ y, y, z);
}

[numthreads(128, 1, 1)]
void VertexIndexBufferClear(uint3 id: SV_DispatchThreadID) {
    VertexIndexBuffer[id.x] = INVALID_VERTEX;
}

// Pass 1: Compute vertex positions for active cells
[numthreads(8, 2, 8)]
void SurfaceNetsVertexPass(uint3 id : SV_DispatchThreadID)
{
    // coordinates of voxel corners in voxel grid coordinate frame
    uint3 cornerIds[8];
    float cornerValues[8];
    for (uint i = 0; i < 8; ++i) {
        const uint3 cornerId = id + CubeVertex(i);
        cornerIds[i] = cornerId;

        cornerValues[i] = all(cornerId < VolumeSize)
            ? (float)Volume.Load(cornerId) : INVALID_SCALAR;
    }

    // store all edge intersection points with the implicit surface in voxel grid coordinates
    // visit every bipolar edge
    /*
    * We approximate the generated mesh vertex using the geometric center of all
    * bipolar edges' intersection point with the implicit surface. The geometric
    * center if first computed in local voxel grid coordinates and will then be
    * mapped to the mesh's coordinates later.
    */
    float totalIntersections = 0;
    float3 addedIntersections = float3(0, 0, 0);
    for (i = 0; i < 12; ++i) {
        const uint2 edge = edgeTable[i];
        
        // get value of the volume at edge vertices
    	const float s1 = cornerValues[edge.x];
    	const float s2 = cornerValues[edge.y];

    	if ((s1 >= ISO_LEVEL) == (s2 >= ISO_LEVEL) // Bipolarity check
            || s1 == INVALID_SCALAR || s2 == INVALID_SCALAR)
    		continue;

    	// get points p1, p2 of the edge e in grid coordinates
    	const float3 p1 = cornerIds[edge.x];
    	const float3 p2 = cornerIds[edge.y];
        
    	// perform linear interpolation using implicit function
    	// values at vertices
    	const float t = (ISO_LEVEL - s1) / (s2 - s1);
    	addedIntersections += p1 + t * (p2 - p1);
    	totalIntersections += 1;
    }

    if (totalIntersections == 0) {
        VertexIndexBuffer[GetVIBufferIndex(id)] = INVALID_VERTEX;
        return;
    }

    const float3 intersectionsCenter = addedIntersections / totalIntersections;
    const float3 vertexPos = VoxelToWorldPos(intersectionsCenter);

    bool isDepthVerified = false;
    if (distance(vertexPos, UserWorldPos) <= MaxMeshUpdateDistance)
    {
        // Get screen space coords of vertex
        const float2 vertexNDC = WorldToNDCPos(vertexPos).xy;

        // Validate coords
        if (all(vertexNDC >= 0.0) && all(vertexNDC <= 1.0)) {
            const float3 depthPos = SampleDepthPosition(vertexNDC);

            // We don't need to calculate which room the vertex is in if it's not occluded by anything
            if (distance(depthPos, vertexPos) <= MetersPerVoxel / 2.0f + 0.03) {
                isDepthVerified = true;
            } else
            {
                // Estimate depth position directly in front of the vertex position, by setting the Y of the sampled
                // depth position to the same as in the vertex position. This is to account for high camera angles
                // distorting the distances between the vertex position and the "real" depth position.
                const float3 adjustedDepthPos = float3(depthPos.x, vertexPos.y, depthPos.z);

                // If the distance between the adjusted position and vertex is less than MetersPerVoxel,
                // it's likely to be in a wall. If it is a larger value, it's likely to be in another room.
                if (distance(adjustedDepthPos, vertexPos) <= MetersPerVoxel * 2.0f) {
                    VertexIndexBuffer[GetVIBufferIndex(id)] = INVALID_DEPTH;
                    return;
                }
            }
        }
    }
    
    if (!isDepthVerified && VertexIndexBuffer[GetVIBufferIndex(id)] == INVALID_DEPTH) {
        return;
    }

    const uint vertexIndex = ValidVertexCounter.IncrementCounter();
    if (vertexIndex >= MaxTriangles * 3) {
        VertexIndexBuffer[GetVIBufferIndex(id)] = INVALID_VERTEX;
        return;
    }

    VertexBuffer[vertexIndex] = vertexPos;
    VertexIndexBuffer[GetVIBufferIndex(id)] = vertexIndex;
}

bool IsInvalidIndex(uint value) {
    return value == INVALID_VERTEX || value == INVALID_DEPTH;
}

// Pass 2: Generate triangles by connecting vertices in neighboring cells
[numthreads(8, 2, 8)]
void SurfaceNetsTrianglePass(uint3 id : SV_DispatchThreadID)
{
    const uint vertexIdx0 = VertexIndexBuffer[GetVIBufferIndex(id)];
    if (IsInvalidIndex(vertexIdx0) || any(id == 0))
        return;
    
	const uint3 neighboringVoxels[6] =
	{
		uint3(id.x - 1, id.y    , id.z    ),
		uint3(id.x - 1, id.y - 1, id.z    ),
		uint3(id.x    , id.y - 1, id.z    ),
		uint3(id.x    , id.y - 1, id.z - 1),
		uint3(id.x    , id.y    , id.z - 1),
		uint3(id.x - 1, id.y    , id.z - 1)
	};

    const float currentValue = (float)Volume.Load(id);
	const float2 edgeValues[3] =
	{
		// directed edge (0,4)
		float2(currentValue, (float)Volume.Load(id + uint3(0,0,1))),
		// directed edge (3,0)
		float2((float)Volume.Load(id + uint3(0,1,0)), currentValue),
		// directed edge (0,1)
		float2(currentValue, (float)Volume.Load(id + uint3(1,0,0)))
	};

    for (uint i = 0; i < 3; ++i) {
        const uint vertexIds[3] =
        {
            VertexIndexBuffer[GetVIBufferIndex(neighboringVoxels[quadNeighbors[i].x])],
            VertexIndexBuffer[GetVIBufferIndex(neighboringVoxels[quadNeighbors[i].y])],
            VertexIndexBuffer[GetVIBufferIndex(neighboringVoxels[quadNeighbors[i].z])]
        };

        if (IsInvalidIndex(vertexIds[0]) || IsInvalidIndex(vertexIds[1]) || IsInvalidIndex(vertexIds[2]))
            continue;

        const uint3 verticesOrder = edgeValues[i].y > edgeValues[i].x
            ? quadNeighborOrders[0] : quadNeighborOrders[1];

        const uint vertexIdx1 = vertexIds[verticesOrder.x];
        const uint vertexIdx2 = vertexIds[verticesOrder.y];
        const uint vertexIdx3 = vertexIds[verticesOrder.z];

        uint triIndex = ValidTriangleCounter.IncrementCounter();
        if (triIndex >= MaxTriangles) return;

        IndexBuffer[triIndex] = uint3(vertexIdx0, vertexIdx1, vertexIdx2);

        triIndex = ValidTriangleCounter.IncrementCounter();
        if (triIndex >= MaxTriangles) return;

        IndexBuffer[triIndex] = uint3(vertexIdx0, vertexIdx2, vertexIdx3);
    }
}